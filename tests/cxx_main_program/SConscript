# Run the alltypes test case, but compile it as C++ instead.
# In fact, compile the entire nanopb using C++ compiler.

Import("env")

# This is needed to get INT32_MIN etc. macros defined
env = env.Clone()
env.Append(CPPDEFINES = ['__STDC_LIMIT_MACROS'])

# Copy the files to .cc extension in order to force C++ build.
c = Copy("$TARGET", "$SOURCE")
env.Command("pb_encode.cc", "#../pb_encode.c", c)
env.Command("pb_decode.cc", "#../pb_decode.c", c)
env.Command("pb_common.cc", "#../pb_common.c", c)

def replace_in_file(src, dst, placeholder, replacement):
    data = open(str(src)).read()
    assert placeholder in data
    data = data.replace(placeholder, replacement)
    open(str(dst), 'w').write(data)

# Build modified en/decode_alltypes.cc
env.Command("encode_alltypes.cc", "#alltypes/encode_alltypes.c",
            lambda target, source, env: replace_in_file(source[0], target[0],
                    '/* namespace placeholder */', 'using namespace test::package;'))
env.Command("decode_alltypes.cc", "#alltypes/decode_alltypes.c",
            lambda target, source, env: replace_in_file(source[0], target[0],
                    '/* namespace placeholder */', 'using namespace test::package;'))

# Build a modified alltypes.proto in C++ mode
env.Command("alltypes.proto", "#alltypes/alltypes.proto",
            lambda target, source, env: replace_in_file(source[0], target[0],
                    '// package name placeholder', 'package test.package;'))
env.NanopbProto(["alltypes.pb.h", "alltypes.pb.cc"], ["alltypes", "alltypes.options"])

# Now build and run the test normally.
enc = env.Program(["encode_alltypes.cc", "alltypes.pb.cc", "pb_encode.cc", "pb_common.cc"])
dec = env.Program(["decode_alltypes.cc", "alltypes.pb.cc", "pb_decode.cc", "pb_common.cc"])

env.RunTest(enc)
env.RunTest([dec, "encode_alltypes.output"])
