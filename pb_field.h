#ifndef _PB_FIELD_H_
#define _PB_FIELD_H_

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>


#ifdef __GNUC__
/* This just reduces memory requirements, but is not required. */
#define pb_packed __attribute__((packed))
#else
#define pb_packed
#endif

/* List of possible field types. These are used in the autogenerated code.
 * Least-significant 4 bits tell the scalar type
 * Most-significant 4 bits specify repeated/required/packed etc.
 *
 * INT32 and UINT32 are treated the same, as are (U)INT64 and (S)FIXED*
 * These types are simply casted to correct field type when they are
 * assigned to the memory pointer.
 * SINT* is different, though, because it is zig-zag coded.
 */

typedef enum {
    /************************
     * Field contents types *
     ************************/

    /* Numeric types */
    PB_LTYPE_VARINT = 0x00, /* int32, uint32, int64, uint64, bool, enum */
    PB_LTYPE_SVARINT = 0x01, /* sint32, sint64 */
    PB_LTYPE_FIXED32 = 0x02, /* fixed32, sfixed32, float */
    PB_LTYPE_FIXED64 = 0x03, /* fixed64, sfixed64, double */

    /* Marker for last packable field type. */
    PB_LTYPE_LAST_PACKABLE = 0x03,

    /* Byte array with pre-allocated buffer.
     * data_size is the length of the allocated PB_BYTES_ARRAY structure. */
    PB_LTYPE_BYTES = 0x04,

    /* String with pre-allocated buffer.
     * data_size is the maximum length. */
    PB_LTYPE_STRING = 0x05,

    /* Submessage
     * submsg_fields is pointer to field descriptions */
    PB_LTYPE_SUBMESSAGE = 0x06,

    /* Number of declared LTYPES */
    PB_LTYPES_COUNT = 7,

    /******************
     * Modifier flags *
     ******************/

    /* Just the basic, write data at data_offset */
    PB_HTYPE_REQUIRED = 0x00,

    /* Write true at size_offset */
    PB_HTYPE_OPTIONAL = 0x10,

    /* Read to pre-allocated array
     * Maximum number of entries is array_size,
     * actual number is stored at size_offset */
    PB_HTYPE_ARRAY = 0x20,

    /* Works for all required/optional/repeated fields.
     * data_offset points to pb_callback_t structure.
     * LTYPE should be 0 (it is ignored, but sometimes
     * used to speculatively index an array). */
    PB_HTYPE_CALLBACK = 0x30

} pb_packed pb_type_t;

#define PB_HTYPE(x) ((x) & 0xF0)
#define PB_LTYPE(x) ((x) & 0x0F)

/* This structure is used for 'bytes' arrays.
 * It has the number of bytes in the beginning, and after that an array.
 * Note that actual structs used will have a different length of bytes array.
 */
typedef struct {
    size_t size;
    uint8_t bytes[1];
} pb_bytes_array_t;

/* The next three pb_field_ structures are used in auto-generated constants
 * to specify struct fields.
 */

typedef struct _pb_field_key_t pb_field_key_t;
typedef struct _pb_field_t pb_field_t;
typedef struct _pb_field_info_t pb_field_info_t;
/* pb_field_key_t is a structure for storing the tag and an index into an array
 * that stores the actual field info. This approach is used to reduce code size
 * as many numeric fields have the same field info.
 *
 * A uint8_t tag will limit the field tag to 128 as the MSB bit is used to indicate
 * whether or not it's the last field in the message. You may change it to uint16_t
 * if you want to specify larger field tag. Please also change the corresponding
 * tag in pb_field_t
 */
typedef uint8_t tag_t;
struct _pb_field_key_t {
    tag_t tag;     /* The MSB bit of the tag is used to indicate it's the last field in the message */
    /* The MSB bit of the info_index is used to indicate the field info is retrieved
     * from the global pb_common_aligned_field_info array instead of the auto-generated field
     * info.
     */
    uint8_t info_index;
} pb_packed;

/* pb_field_t is a structure for storing the pb field descriptor information
 * You can change field sizes here if you need structures
 * larger than 256 bytes
 */
struct _pb_field_t {
    tag_t tag;
    pb_type_t type;
    uint8_t data_offset; /* Offset of field data, relative to previous field. */
    int8_t size_offset; /* Offset of array size or has-boolean, relative to data */
    uint8_t data_size; /* Data size in bytes for a single item */
    uint8_t array_size; /* Maximum number of entries in array */

    /* Field definitions for submessage
     * OR default value for all other non-array, non-callback types
     * If null, then field will zeroed. */
    const void *ptr;
} pb_packed;

/* pb_field_info_t is the structure for holding together the key and the field info arrays.
 * This is the structure that will be passed to pb_encode and pb_decode
 */
struct _pb_field_info_t {
    const pb_field_key_t *field_keys;
    const pb_field_t *field_info;
};

/* Iterator for pb_field_t list */
typedef struct {
    const pb_field_key_t *start_key;
    const pb_field_key_t *current_key;
    pb_field_t current;
    const pb_field_t *field_info;
    int field_index;
    void *dest_struct;
    void *pData;
    void *pSize;
} pb_field_iterator_t;

/* Functions for iterating through the field */
void pb_field_init(pb_field_iterator_t *iter, const pb_field_info_t *fields, void *dest_struct);
bool pb_field_next(pb_field_iterator_t *iter);
bool pb_field_find(pb_field_iterator_t *iter, int tag);

/* These macros are used to declare pb_field_t's in the constant array. */
#define pb_membersize(st, m) (sizeof ((st*)0)->m)
#define pb_arraysize(st, m) (pb_membersize(st, m) / pb_membersize(st, m[0]))
#define pb_delta(st, m1, m2) ((int)offsetof(st, m1) - (int)offsetof(st, m2))
#define pb_delta_end(st, m1, m2) (offsetof(st, m1) - offsetof(st, m2) - pb_membersize(st, m2))

/* The MSB bit of the pb_field_key_t.tag indicates whether or not it's the last element */
#define PB_LAST_FIELD (0x1 << (pb_membersize(pb_field_key_t, tag) * 8 - 1))
#define PB_IS_LAST(key) ((key)->tag & PB_LAST_FIELD)
#define PB_TAG_VAL(key) ((key)->tag & ~PB_LAST_FIELD)

/* The MSB bit of the pb_field_key_tag.info_index indicates whether it's a common or generated field info */
#define PB_COMMON_INFO_FLAG (0x1 << (pb_membersize(pb_field_key_t, info_index) * 8 -1))

/* A common field info is retrieved from the globally declared pb_common_aligned_field_info array or
 * locally auto-generated field info array */
#define PB_FIELD_INFO(key, info) (((key)->info_index & PB_COMMON_INFO_FLAG) ? \
    &pb_common_aligned_field_info[(key)->info_index ^ PB_COMMON_INFO_FLAG] : \
    &((info)[(key)->info_index]))

/* Defines the indices for pb_common_aligned_field_info array
 * Note that MSB bit PB_COMMON_INFO_FLAG is set to indicate the index
 * should be used on pb_common_aligned_field_info instead of generated
 * array
 * */
enum {
    REQUIRED_BOOL_INFO = 0 | PB_COMMON_INFO_FLAG,
    OPTIONAL_BOOL_INFO = 1 | PB_COMMON_INFO_FLAG,
    REQUIRED_INT32_INFO = 2 | PB_COMMON_INFO_FLAG,
    OPTIONAL_INT32_INFO = 3 | PB_COMMON_INFO_FLAG,
    REQUIRED_INT64_INFO = 4 | PB_COMMON_INFO_FLAG,
    OPTIONAL_INT64_INFO = 5 | PB_COMMON_INFO_FLAG,
    REQUIRED_SINT32_INFO = 6 | PB_COMMON_INFO_FLAG,
    OPTIONAL_SINT32_INFO = 7 | PB_COMMON_INFO_FLAG,
    REQUIRED_SINT64_INFO = 8 | PB_COMMON_INFO_FLAG,
    OPTIONAL_SINT64_INFO = 9 | PB_COMMON_INFO_FLAG,
    REQUIRED_FIXED32_INFO = 10 | PB_COMMON_INFO_FLAG,
    OPTIONAL_FIXED32_INFO = 11 | PB_COMMON_INFO_FLAG,
    REQUIRED_FIXED64_INFO = 12 | PB_COMMON_INFO_FLAG,
    OPTIONAL_FIXED64_INFO = 13 | PB_COMMON_INFO_FLAG,

    /* leave this enum to determine num of elements */
    MAX_COMMON_FIELD_INFO
};

#define NUM_COMMON_FIELD_INFO (MAX_COMMON_FIELD_INFO ^ PB_COMMON_INFO_FLAG)

/* pb_common_aligned_field_info array holds the common field info that can be shared
 * by any numeric fields whose previous field is memory aligned
 */
extern const pb_field_t pb_common_aligned_field_info[NUM_COMMON_FIELD_INFO];

#endif /* _PB_FIELD_H_ */
